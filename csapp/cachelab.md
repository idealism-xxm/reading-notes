## 简介

Architecture Lab 属于《深入理解计算机》第四章和第五章。这 Lab 第一部分和第二部分仅需要第四章——处理器体系结构的知识，主要用于练习汇编指令和控制逻辑设计；第三部分需要第五章——优化程序性能的知识，主要通过循环展开等技术进一步提高程序的 CPE 。

## 知识点回顾

### 局部性 `P418`

一个编写良好的计算机程序常常具有良好的局部性。现代计算机系统的各个层次，从硬件到操作系统、再到应用程序，它们的设计都利用了局部性。所以只要我们的程序有良好的局部性，那么执行的速度将有质的提升。

局部性通常有两种不同的形式：
- 时间局部性：被引用过一次的内存位置很可能在不远的将来再被多次引用
- 空间局部性：一个内存位置被引用过一次，很可能在不远的将来引用其附近的一个内存位置

```c
int sumvec(int v[N]) {
    int i, sum = 0;
    for (i = 0; i < N; i++) {
        sum += v[i];
    }
}
```

上面这个简单的循环求和就具有良好的局部性： `sum` 和 `i` 具有良好的时间局部性，数组 `v` 具有良好的空间局部性。

### 空间局部性的重要性 `P447`

即使程序的时间局部性很差，但空间局部性仍然能补救，并且非常重要。 `P445`

下面这个例子告诉我么空间局部性的重要性，并让我们将注意力集中在内循环上。

考虑一对 `n * n` 矩阵相乘的问题： C = AB 。有以下 6 个版本的计算方法（假设为整型或者浮点数加法可结合）：

```c
// a) ijk 版本
for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
        sum = 0;
        for (k = 0; k < n; k++) {
            sum += A[i][k] * B[k][j];
        }
        C[i][j] += sum;
    }
}

// b) jik 版本
for (j = 0; j < n; j++) {
    for (i = 0; i < n; i++) {
        sum = 0;
        for (k = 0; k < n; k++) {
            sum += A[i][k] * B[k][j];
        }
        C[i][j] += sum;
    }
}

// c) jki 版本
for (j = 0; j < n; j++) {
    for (k = 0; k < n; k++) {
        r = B[k][j];
        for (i = 0; i < n; i++) {
            C[i][j] += A[i][k] * r;
        }
    }
}

// d) kji 版本
for (k = 0; k < n; k++) {
    for (j = 0; j < n; j++) {
        r = B[k][j];
        for (i = 0; i < n; i++) {
            C[i][j] += A[i][k] * r;
        }
    }
}

// e) kij 版本
for (k = 0; k < n; k++) {
    for (i = 0; i < n; i++) {
        r = A[i][k];
        for (j = 0; j < n; j++) {
            C[i][j] += r * B[k][j];
        }
    }
}

// f) ikj 版本
for (i = 0; i < n; i++) {
    for (k = 0; k < n; k++) {
        r = A[i][k];
        for (j = 0; j < n; j++) {
            C[i][j] += r * B[k][j];
        }
    }
}
```

![图 6-46 Core i7 矩阵乘法性能](img/图%206-46%20Core%20i7%20矩阵乘法性能.png)

上图现实了前面 6 个版本的性能，可以发现它们成对分成了三条折线：对于大的 n 值，最慢的版本比最快的版本慢了近 40 倍，这足以说明空间局部性的重要性了。

我们在列出这 6 个版本每次迭代的加载存储次数和不命中次数：

| 矩阵乘法版本 (类) | 加载次数 | 存储次数 | A 未命中次数 | B 未命中次数 | C 未命中次数 | 总未命中次数 |
| --- |  --- |  --- |  --- |  --- |  --- |  --- |
| ijk & jik (AB) | 2 | 0 | 0.25 | 1.00 | 0.00 | 1.25 |
| jki & kji (AC) | 2 | 1 | 1.00 | 0.00 | 1.00 | 2.00 |
| kij & ikj (BC) | 2 | 1 | 0.00 | 0.25 | 0.25 | 0.50 |

这 6 个版本成对地形成了 3 个等价类，用内循环中访问的矩阵对来表示每个类，并分析内循环中 ABC 每次迭代的不明中次数：
- 类 AB: a, b 两个版本最内层引用的是矩阵 AB ，这也是我们最常见的写法
    - 以步长为 1 扫描 A 一行，每个高速缓存块会保存四个 8 字节的字，所以平摊下来 A 的每次迭代不命中 0.25 次
    - 以步长为 n 扫描 B 一列，因为 n 很大，所以每次对 B 的访问都会不命中，即 B 每次迭代不命中 1 次
    - 未引用 C ，所以 C 的每次迭代不命中 0 次
- 类 AC: c, d 两个版本最内层引用的是矩阵 AC ，与类 AB 相比，交换了内循环降低了空间局部性
    - 以步长为 n 扫描 A 一列，因为 n 很大，所以每次对 A 的访问都会不命中，即 A 每次迭代不命中 1 次
    - 未引用 B ，所以 B 的每次迭代不命中 0 次
    - 以步长为 n 扫描 C 一列，因为 n 很大，所以每次对 C 的访问都会不命中，即 C 每次迭代不命中 1 次
- 类 BC: e, f 两个版本最内层引用的是矩阵 BC
    - 未引用 A ，所以 A 的每次迭代不命中 0 次
    - 以步长为 1 扫描 B 一行，每个高速缓存块会保存四个 8 字节的字，所以平摊下来 B 的每次迭代不命中 0.25 次
    - 以步长为 1 扫描 C 一行，每个高速缓存块会保存四个 8 字节的字，所以平摊下来 C 的每次迭代不命中 0.25 次

## 准备

可以在 [官网](http://csapp.cs.cmu.edu/3e/labs.html) 下载 Cache Lab 相关的程序。

开始前需要阅读 [Cache Lab writeup](http://csapp.cs.cmu.edu/3e/cachelab.pdf) ，可以知道本次 Lab 由 2 部分组成：第一部分让我们实现一个缓存模拟器（大概不到 300 行代码），第二部分让我们实现一个转置函数去充分利用缓存。

本次需要使用的程序依旧需要在 Docker 中运行，将本地 Lab 的目录挂载进容器中即可：

```shell script
docker run -ti -v {PWD}:/csapp ubuntu:18.04
```

进入容器后需要安装一些必须软件以便后续能成功运行：

```shell script
apt-get update && apt-get -y install gcc make valgrind
```

然后就可以愉快的开始闯关了。

## 闯关

### 第一部分

第一部分主要是写 LRU 内存模拟器，读入 `valgrind` 生成的内存访问记录，按顺序执行对应的内存操作：忽略以 `I` 开头的指令加载，只处理以 ` L`, ` S`, ` M` 开头的数据加载、数据存储和数据修改，按照书中 6.4.3 (`P433`) 中介绍的组相联高速缓存模拟这三个数据内存操作，并记录命中次数、未命中次数和驱逐次数。

注意：`L` 和 `S` 操作要么是一个命中，要么是一个未命中（有可能附带一个驱逐）；`M` 操作会被处理成先 `L` 再 `S` 操作，所以前者可能未命中（有可能附带一个驱逐），但后者必定命中。

由于组相联高速缓存很规整，第一维是长度 S 的缓存组，第二维是长度 E 的缓存行，所以我们可以使用一个二维数组模拟即可，元素的类型就是缓存行，仅存储标记等信息，不需要数据。

按照这个程序执行的流程可继续划分成三个部分：处理参数、初始化缓存、处理 trace 文件数据。

#### 处理参数

参数处理虽然不是我们的核心功能，但为了和原有程序保持一直，我们使用指南中提到的 `getopt` 库函数处理命令行入参数，这个库函数可以很方便处理各种必填/可选的选项。

```c
// 处理调用参数
void handle_args(int argc, char *argv[]) {
    // 接收 getopt 的返回值，表明当前处理的 flag
    int opt;

    // getopt 第三个参数表明所有选项，不可省略的选项字符后要跟冒号
    while(-1 != (opt = (getopt(argc, argv, "hvs:E:b:t:")))) {
        switch(opt) {
            case 'h':
                // usage 是我们定义的打印帮助函数的方法，就不展示了
                usage(argv[0]);
                break;
            case 'v':
                verbose = true;
                break;
            case 's':
                s = atoi(optarg);
                break;
            case 'E':
                E = atoi(optarg);
                break;
            case 'b':
                b = atoi(optarg);
                break;
            case 't':
                strcpy(tracefile_path, optarg);
                break;
            default:
                usage(argv[0]);
                break;
        }
    }
}
```

#### 初始化缓存

参数读取成功了，我们就需要初始化缓存及其相关数据了。

由于本 Lab 不需要存取数据，所以缓存行省略了缓存块，仅保留有效位、标记和上次访问时间，其中上次访问时间在执行 LRU 驱逐的时候使用。

初始化缓存时，我们需要先计算出组数 S 和缓存块大小 B 。然后给我们的缓存 `cache` 二维数组分配空间，先分配缓存组的空间，再分配每个缓存组的缓存行的空间，并同时设置每个缓存行未使用。

```c
typedef struct {
    // 有效位
    bool valid;
    // 标记
    int tag;
    // 上次访问时间
    int timestamp;
    // 由于本实验不需要存取数据，所以缓存块省略了
} CacheLine;

// 缓存的分布就类似一个二分数组
// 第一维用于定位在哪一组
// 第二维用于定位该组中的哪一行
CacheLine** cache;

// 初始化缓存
void init_cache() {
    int i, j;
    // 总共 2 ^ s 组
    S = 1 << s;
    // 每个缓存块供 2 ^ b 字节
    B = 1 << b;

    // 先分配 S 个缓存组的空间
    cache = (CacheLine**) malloc(sizeof(CacheLine*) * S);
    for (i = 0; i < S; i++) {
        // 再分配每个缓存组中的缓存行空间
        cache[i] = (CacheLine*) malloc(sizeof(CacheLine) * E);
        // 然后初始化每个缓存行的数据
        for (j = 0; j < E; j++) {
            cache[i][j].valid = false;
        }
    }
}
```

#### 处理 trace 文件数据

这一部分是我们缓存模拟器的核心代码，可以再细分为两个部分：读取 trace 文件每一行、对每一行执行对应的内存操作。

文件读取非常简单，就不赘述了，主要是三种内存操作。由于本 Lab 没有数据的使用，所以 Load 和 Store 操作可以合二为一，而 Modify 操作又可以拆分为先后执行 Load 和 Store 操作，最终我们可以使用一个 `load_or_store` 函数就可以统一这三种操作的情况。

`load_or_store` 函数的核心逻辑：
1. 通过地址获取缓存组下标和标记，然后遍历这个缓存组中的缓存行
2. 当发现缓存行有效且标记等于目标地址的标记，就说明命中缓存，记录统计数据后直接返回
3. 同时遍历的过程中还需要记录最后一个无效的缓存行，以及最早访问的有效的缓存行，用于未命中时的处理
4. 遍历完成后即表明未命中缓存，记录统计输出，然后判断是否需要驱逐
5. 将该地址的数据放入 3 中记录的缓存行中

```c
// 由于没有数据块，所以我们可以把 L 和 S 统一处理
// 0: 命中
// 1: 未命中未驱逐
// 2: 未命中已驱逐
int load_or_store(int address) {
    int j, info = 0;
    // 获取该地址对应的组下标
    int set_index = (address >> b) & (S - 1);
    // 获取该地址对应的行 tag
    int line_tag = address >> (s + b);
    // 假设可能失败且该组已满，这样我们可以一次循环处理出来结果
    int line_index = -1;
    // 同时假设可能失败且该组未满，这样我们可以一次循环处理出来结果
    int invalid_line = -1;
    for (j = 0; j < E; j++) {
        if (!cache[set_index][j].valid) {
            // 如果最后发现未命中缓存，那么该缓存行将存储这个数据
            invalid_line = j;
            continue;
        }

        // 如果是我们要找的地址，那么 命中 + 1 ，更新访问时间
        if (cache[set_index][j].tag == line_tag) {
            hits++;
            cache[set_index][j].timestamp = timestamp;
            return 0;
        }
        // 如果不是我们要找的地址，那么找到最早访问的行
        if (line_index == -1 || cache[set_index][line_index].timestamp > cache[set_index][j].timestamp) {
            line_index = j;
        }
    }

    // 此时没有命中
    misses++;
    info++;
    if (invalid_line == -1) {
        // 如果没有可用的行，则需要驱逐
        evictions++;
        info++;
        invalid_line = line_index;
    }
    // 将缓存放入该行，并更新对应的信息
    cache[set_index][invalid_line].valid = true;
    cache[set_index][invalid_line].tag = line_tag;
    cache[set_index][invalid_line].timestamp = timestamp;
    return info;
}
```

### 第二部分

第二部分要求我们对三种不同大小的矩阵写对应的转置函数，使得最终的缓存未命中次数 `m` 最小。

- `32 × 32`: 
    - m < 300: 满分
    - m > 600: 零分
- `64 × 64`: 8 points if m < 1, 300, 0 points if m > 2, 000
    - m < 1300: 满分
    - m > 2000: 零分
- `61 × 67`: 10 points if m < 2, 000, 0 points if m > 3, 000
    - m < 2000: 满分
    - m > 3000: 零分

本部分的一些限制条件如下：

- 最多使用 12 个 `int` 变量
- 不能使用未运算将多个值放到一个变量中
- 不能使用递归进行转置
- 不能修改 A ，可以随意修改 B
- 不能定义新的数组或分配内存
- 缓存参数： s = 5, E = 1, b = 5

**注意**：本部分使用 `./test-trans` 命令时需要确保程序在 Linux 机器内的文件夹下，而非我们挂在的目录中，否则会出现跑不出结果的问题。

#### `32 × 32`

自带的简单转置函数很直观，没有其他知识也想不出更好的方法了。先跑一下这个结果，发现未命中次数为 `1183` 次，离目标 `300` 次以下还有很远，这时和做 [Architecture Lab](archlab.md) 最后一部分一样有点不知所措，不过指南最后提到了使用分块的方法可以优化，就继续学习 [分块技术](http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf) 。

分块技术的核心就是将矩阵划分成更小的块进行处理，使得每次处理的数据都能放入缓存中，并降低缓存在下次被使用前就被驱逐的概率。

题目限制我们使用的缓存行的缓存块大小为 `2 ^ 5 = 32` 个字节，可以存下 8 个整型，所以我们可以将分块大小定为 8 ，那么不冲突的情况下需要使用 16 个缓存组，可以全部存下。这种情况下按照分块文档中提到的估计理论未命中次数是 `4 * 4 * 16 = 256` （总共有 `4 * 4` 个块，由于缓存组足够，那么不会产生驱逐，所以每个块中 A 和 B 各有 8 次无法避免的未命中）

```c
void trans_32_32(int M, int N, int A[N][M], int B[M][N]) {
    int i, j, k, l;
    for (i = 0; i < N; i += 8) {
        for (j = 0; j < M; j += 8) {
            for (k = i; k < (i + 8); k++) {
                for (l = j; l < (j + 8); l++) {
                    B[l][k] = A[k][l];
                }
            }
        }
    }
}
```

运行后发现未命中次数是 `343` ，距离理论居然差这么多。我们只能继续分析哪里贡献了多余的未命中次数。

查看 trace 文件后，我们发现 A 的起始地址是 `0x30a0c0` ， B 的起始地址是 `0x34a0c0` ，计算后发现 A 和 B 对应下标的地址会被映射到同一个缓存组（感到被针对），那么在进行转置的过程中，赋值 `B[0][0]` 时就会驱逐 `A[0][0]` 刚刚缓存的数据 ，导致 A 中还未使用的缓存数据白白浪费。这与我们开始设想的不会冲突有出入，所以我们必须处理这种冲突情况。

可以发现在处理 `B[l][k] = A[k][l]` 时，只有当 `k == l` 时才会出现刚刚所说的冲突，所以我们只要避免这种情况就行，我们可以提前将 A 中的 8 个整型一次性读入到临时变量中，保证内循环每次迭代时 A 只有一次未命中次未命中。

```c
void trans_32_32(int M, int N, int A[N][M], int B[M][N]) {
    int i, j, k;
    int v0, v1, v2, v3, v4, v5, v6, v7;
    for (i = 0; i < N; i += 8) {
        for (j = 0; j < M; j += 8) {
            for (k = i; k < (i + 8); k++) {
                v0 = A[k][j];
                v1 = A[k][j + 1];
                v2 = A[k][j + 2];
                v3 = A[k][j + 3];
                v4 = A[k][j + 4];
                v5 = A[k][j + 5];
                v6 = A[k][j + 6];
                v7 = A[k][j + 7];
                B[j][k] = v0;
                B[j + 1][k] = v1;
                B[j + 2][k] = v2;
                B[j + 3][k] = v3;
                B[j + 4][k] = v4;
                B[j + 5][k] = v5;
                B[j + 6][k] = v6;
                B[j + 7][k] = v7;
            }
        }
    }
}
```

这次未命中次数降为 `287` ，已经可以取得满分，但是这个未命中次数距离理论上未命中次数 `4 * 4 * (8 + 8) = 256` 还有一定距离，还有优化的地方。

刚刚我们只解决了 A 的冲突，并没有解决 B 的冲突， B 的冲突同样也只会出现在 `k == l` 时。例如：当 A 访问第 1 行时， B 会缓存 1 ~ 8 行，而接下来 A 会访问第 2 行，导致 B 缓存的第 2 行被白白浪费。所以我们需要在 B 访问第 2 行之前就取出 A 中第 2 行的数据，即最开始我们就需要从 A 中取出两行数据，然后再开始写入 B 。