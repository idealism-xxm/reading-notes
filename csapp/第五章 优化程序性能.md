## 简介

本章为《深入理解计算机系统》第五章——优化程序性能，通过各种影响性能的例子，引出了基本编码原则可以让编译器产生高效的代码；通过介绍现代处理器的执行流程，让我们通过结构化的代码充分利用硬件功能。

## 知识点回顾

### 优化的局限性

开篇就给出了两个优化会出错的例子，然而我还没看出来。

#### 内存别名使用

```c
x = 1000;
y = 3000;
*q = y;    // 3000
*p = x;    // 1000
t1 = *q    // 1000 or 3000
```

答案都给出来了，可是想了半天还是没想明白为什么 `t1` 可以是 `1000` ，发现自己思维还是不够活跃。

在只执行安全的优化中，必须假设不同的指针可能会指向内存中同一个位置。 `P343`

如果 `p` 和 `q` 都指向内存的同一个位置，那么最终 `t1` 就是 `1000` ，否则 `t1` 就是 `3000` 。

#### 函数调用及副作用

```c
long f();

long func1() {
    return f() + f() + f() + f();
}

long func2() {
    return 4 * f();
}
```

一眼看下去，这两个函数的计算结果一致，但是 `func2` 只调用 `f` 一次，而 `func1` 会调用 `f` 四次。如果 `f` 的实现如下：

```c
long counter = 0;

long f() {
    return counter++;
}
```

那么它有一个副作用：修改了全局状态的一部分，改变调用次数会改变程序的行为，最终会改变两个函数的计算结果。

我们人工常用的优化手段就是将无副作用、结果不变（且耗时）的函数调用提到循环外，例如常见的遍历字符串操作，最差情况下是每次都求字符串长度 `for(i = 0; i < strlen(s); i++)` ，优化后就为 `for(i = 0, length = strlen(s); i < length; i++)` ，很明显会极大提升性能。

以前没想过这样的情况为什么需要人工优化，只是默默地在遇到类似的情况时人工处理，而没有关注到和其他会被优化之处的差别（当然也仅仅注意到循环中使用 `vector` 且有添加/删除操作时不能优化，因为循环中的操作添加/删除会影响每次 `vec.end()` 返回的值）。现在看起来就是因为函数调用存在副作用，编译器不知道是否存在影响，所以为了保证执行安全就不会优化；而人知道函数的实现，确定无副作用，所以可以放心优化。

### 消除不必要的内存引用 `P354`

内存引用同样会降低程序性能，所以可以按照函数的实际语义进行特定的优化。 

```c
// 内存引用（不开优化）
void multiply1(double arr[], long length, double* dest) {
    long i;
    *dest = 0;
    for (i = 0; i < length; i++) {
        *dest = *dest * arr[i];
    }
}

// multiply1 开了 -O2 后，汇编对应的 C 代码
void multiply2(double arr[], long length, double* dest) {
    long i;
    double res = 0;
    *dest = 0;
    for (i = 0; i < length; i++) {
        res = res * arr[i];
        *dest = res;
    }
}

// 人工优化
void multiply3(double arr[], long length, double* dest) {
    long i;
    double res = 0;
    for (i = 0; i < length; i++) {
        res = res * arr[i];
    }
    *dest = res;
}
```

在函数 `multiply1` 中由于存在内存引用，不开优化时生成的汇编中，每次循环都有三个操作：读内存一次（因为乘法的两个操作数不能都在内存中）、执行乘法、写内存一次。

函数 `multiply2` 是编译器开了 `-O2` 优化后对应的 C 语言代码，我们可以看到由于使用了一个临时变量，所以乘法操作不需要再读取内存，每次循环只有两个操作：执行乘法、写内存一次。

在函数 `multiply3` 中我们根据函数 `multiply1` 的语义进行了人工优化，代码不需要额外读内存，也不需要写内存，所以生成的汇编代码中，每次循环只有一个操作：执行乘法。

- 但这种优化有一个问题，就是最开始提到的内存别名使用，如果 `arr = [2, 3, 5]` ，那么 `multiply1(arr, 3, arr + 2)` 最终会得到 `arr[2] = 36` ，而 `multiply3(arr, 3, arr + 2)` 最终会得到 `arr[2] = 30` ，两者结果不一致。

### 处理器运算的性能 `P361`

[处理器体系结构](archlab.md) 中我们介绍的流水线处理器是顺序的，并且一个周期内只能处理一个相同操作，而现代处理器是乱序的（指令的执行顺序不一定与机器级代码中的指令顺序一致），并且一个周期内可以和执行多个相同操作（称为超标量）。后续的介绍学习分析都是基于现代处理器。

处理器的每个运算都是由以下三个数值来刻画的： `P361`

- 延迟：表示完成运算所需的总时钟周期数
- 发射时间：表示两个连续的同类型运算之间需要的最小时钟周期数
- 容量：表示能够执行该运算的功能单元的数量（每个周期可发射的运算数）

运算的延迟、发射时间和容量会影响合并函数的性能。可以用 CPE (Cycles Per Element, 每元素的周期数) 值的两个基本界限来描述这种影响： `P362`

- 延迟界限：等于延迟，给出了任何必须按照严格顺序完成合并运算的函数所需要的最小 CPE 值
- 吞吐量界限：等于 发射时间/容量，给出了 CPE 的最小界限

### 处理器操作的抽象模型 `P362`

数据流通过图形化的方法，展现了不同操作之间的数据相关是如何限制它们的执行顺序的。这些限制形成了数据流图中的关键路径，这是执行一组机器指令所需时钟周期数的一个下界。 `P362`

现在我们先根据前面提到的函数 `multiply3` 中的循环举例分析：

```assemble
# 函数 multiply3 的内循环汇编代码片段
# res in %xmm0, arr + i in %rdx, arr + length in %rax
.L25:
    vmulsd (%rdx), %xmm0, %xmm0  # res *= arr[i]
    addq $8, %rdx                # i += 1
    cmpq %rax, %rdx              # 比较 i 和 length
    jne .L25                     # 如果不等于，则继续执行循环
```

我们假设指令译码会把这 4 条指令扩展成一系列的五个操作，最开始的乘法指令会被扩展成一个 `load` 操作（从内存中读出源操作数）和一个 `mul` 操作（执行乘法），那么这五个操作的图形化表示如下：

![图 5-13 内循环代码的图形化表示](img/图%205-13%20内循环代码的图形化表示.png)

其中顶部的方框表示循环开始时寄存器的值，底部的方框表示循环结束时寄存器的值。

对于形成循环的代码片段，可以将访问到的寄存器分为四类： `P363`

- 只读：这些寄存器只用作源值，在循环中不会被修改。例如：寄存器 `%rax`
- 只写：这些寄存器只作为数据传送操作的目的，在循环中不会作为源值
- 局部：这些寄存器在循环内部被修改和使用，迭代与迭代之间不相关。例如：条件码寄存器
- 循环：这些寄存器即作为源值，又作为目的，一次迭代中产生的值会在另一次迭代中用到。例如：寄存器 `%rdx` 和 `%xmm0`

循环寄存器之间的操作链决定了限制性能的数据相关。 `P364`

现在我们改进刚刚的图形化表示，只给出影响程序执行时间的操作和数据相关，更清晰地表明了从顶部源寄存器（只读寄存器和循环寄存器）到底部目的寄存器（只写寄存器和循环寄存器）的数据流。 `P364`

![图 5-14 抽象成数据流图.png](img/图%205-14%20抽象成数据流图.png)

左侧图白色方框表明不属于某个循环寄存器之间的相关链，我们可以进一步优化，只保留循环寄存器，得到一个抽象的模版，得出右侧图。右侧图表明由于循环的一次迭代在循环寄存器中形成的数据相关。

通过右侧图我们可以发现：程序有两条数据相关链，分别对应与操作 `mul` 和 `add` 对程序值 `res` 和 `i` 的修改。假设浮点乘法延迟为 `5` 个周期，而整数加法延迟为 `1` 个周期，那么在 `n` 次循环中，左边的链会成为关键路径，需要 `5n` 个周期执行；右边的链只需要 `n` 个周期，因此它不会制约程序的性能（现代处理器有多个功能单元，可以同时执行多个运算，在执行浮点乘法之间可以执行该加法）。 `P365`

#### 练习题 5.5 `P365`

有一个对多项式求值的函数计算 `a0 + a1 * x + a2 * (x^2) + ... + an * (x^n)` ，对应的 C 代码如下：

```c
double poly(double a[], double x, long degree) {
    long i;
    double result = a[0];
    double xpwr = x;
    for (i = 1; i <= degree; i++) {
        result += a[i] * xpwr;
        xpwr = x * xpwr;
    }
    return result;
}
```

这个函数的 CPE 值等于 5 ，根据循环中的操作迭代之间形成的数据链相关，解释为什么会得到这样的 CPE ？

![练习题 5.5 数据流图](img/练习题%205.5%20数据流图.png)

这个函数的循环部分的数据流图如上所示，程序有三条数据相关链：分别对应对程序值 `result`, `xpwr` 和 `i` 的修改。在一次迭代中，两个浮点乘法和右侧整数加法可以同时开始计算，占用 `5` 个周期，而对 `result` 的浮点加法占用 `3` 个周期，可以在下一次迭代计算乘法时再执行这个浮点加法。那么在足够长的 `n` 次循环中，关键链就是 `xpwr = x * xpwr` 这个操作，占用 `5` 个周期，因此一次迭代只需要占用 `5` 周期即可完成，即 `CPE = 5` 。

#### 练习题 5.6 `P366`

我们对通过 Horner 法（反复提出 `x` 的幂）对多项式求值的函数计算 `a0 + x * (a1 + x * (a2 + ... + x * (a[n-1]) + an * x^n)...)` ，对应的 C 代码如下：

```c
double poly(double a[], double x, long degree) {
    long i;
    double result = a[degree];
    for (i = degree - 1; i >= 0; i--) {
        result = a[i] + x * result;
    }
    return result;
}
```

这种方法减少了乘法计算的数量，但 CPE 却变为 8 ，根据循环中的操作迭代之间形成的数据链相关，解释为什么会得到这样的 CPE ？

![练习题 5.6 数据流图](img/练习题%205.6%20数据流图.png)

这个函数的循环部分的数据流图如上所示，程序有两条数据相关链：分别对应对程序值 `result`, 和 `i` 的修改。在一次迭代中，必须先进行浮点乘法 `tmp = x * result`，占用 `5` 个周期，再进行浮点加法 `result = result + tmp`，这两个操作无法拆分出来，因为下一次迭代的乘法依赖本次迭代的加法；而右侧整数加法操作可以同时进行，不占用额外周期。那么在足够长的 `n` 次循环中，关键链就是 `result = a[i] + x * result` 这个操作，占用 `8` 个周期，因此一次迭代需要占用 `8` 周期完成，即 `CPE = 8` 。

### 循环展开

循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少迭代的迭代次数。它能够从两个方面改进程序的性能： `P366`

- 减少了不直接有助于程序结果的操作数量，例如循环索引计算和条件分支
- 提供了一些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量

`k * 1` 循环展开即每次循环时执行展开前的循环体 `k` 次，直至循环次数不足 `k` 次，然后再执行 `0 ~ k-1` 次展开前的循环。基本方法是：将循环上限设为 `n - k + 1` ，在循环内对元素 `i` 到 `i + k - 1` 应用合并 运算。每次迭代，循环索引 `i` 加 `k` 。那么最大循环索引 `i + k - 1` 会小于 `n` 。然后再以每次处理的方式处理最后几个元素，这个循环体将执行 `0 ~ k-1` 次。 `P366`

如果我们对函数 `multiply3` 使用 `2 * 1` 循环展开，那么对应的 C 语言代码如下：

```c
void multiply4(double arr[], long length, double* dest) {
    long i;
    long limit = length - 2 + 1;
    double res = 0;
    for (i = 0; i < limit; i += 2) {
        res = res * arr[i] * arr[i + 1];
    }
    for (; i < length; i++) {
        res = res * arr[i];
    }
    *dest = res;
}
```

![图 5.19 multiply3 使用 2 * 1 循环展开的数据流图](img/图%205.19%20multiply3%20使用%202%20*%201%20循环展开的数据流图.png)

可以发现此时关键路径还是左侧链，并且该路径上有两个顺序的浮点乘法，并没有改善 CPE 。

### 多个累积变量

程序的性能受运算单元的延迟限制，但这些运算单元可以流水线化，并且有些操作可以被多个功能单元执行。而前面的代码不能利用这种能力，即使循环展开也不能，因为我们将累积值放在一个单独的变量 `res` 中。在前面的计算完成之前，都不能计算 `res` 的新值。虽然计算 `res` 新值的功能单元能够每个时钟周期开始一个新的操作，但是它只会每 `L` 个周期开始一条新操作，这里 `L` 是合并操作的延迟。

对于一个可结合和可交换的合并运算来说（比如整数加法和乘法），我们可以通过将一组合并运算分割成两个或更多的部分，并在最后合并来提高性能。例如： Pn 表示元素 a0, a1, ..., a[n-1] 的乘积，假设 `n` 为偶数，那么 `Pn = PEn * POn` ，其中 `PEn` 是索引值为偶数的元素乘积， `POn` 是索引值为奇数的元素的乘积。

函数 `multiply4` 使用多个累积变量可以被继续优化成以下形式：

```c
void multiply5(double arr[], long length, double* dest) {
    long i;
    long limit = length - 2 + 1;
    double res_even = 0;
    double res_odd = 0;
    for (i = 0; i < limit; i += 2) {
        res_even = res_even * arr[i];
        res_odd = res_odd * arr[i + 1];
    }
    for (; i < length; i++) {
        res_even = res_even * arr[i];
    }
    *dest = res_even * res_odd;
}
```

![图 5-23 multiply3 使用 2 * 2 循环展开的数据流图](img/图%205-23%20multiply3%20使用%202%20*%202%20循环展开的数据流图.png)

函数 `multiply5` 这种形式称为 `2 * 2` 循环展开，这种方法可以打破由延迟界限设下的限制。从数据流图可以看到关键路径上的浮点乘法都只有 1 个，每 5 个周期可以并行计算出 2 个乘积，所以 CPE 变为 2.5 。

`k * k` 循环展开就是循环展开 `k` 次，并行累积 `k` 个值。 `P371`

对于延迟为 `L` ，容量为 `C` 的操作而言，当循环展开因子 `k <= C * L` 时，程序才能达到这个操作的吞吐量界限。 `P371`

**注意**：浮点乘法和加法不是可结合的，因为存在精度问题而进行四舍五入，所以 `multiply4` 和 `multiply5` 的结果可能不同。

### 重结合变换

前面多个累积变量的方式通过打破顺序相关使性能提高到延迟界限之外，重结合变换也通过打破顺序相关使性能提高到延迟界限之外。 `P373`

函数 `multiply4` 使用重结合变化可以被继续优化成以下形式，仅仅是将 `res = res * arr[i] * arr[i + 1]` 变为 `res = res * (arr[i] * arr[i + 1])` ：

```c
void multiply6(double arr[], long length, double* dest) {
    long i;
    long limit = length - 2 + 1;
    double res = 0;
    for (i = 0; i < limit; i += 2) {
        res = res * (arr[i] * arr[i + 1]);
    }
    for (; i < length; i++) {
        res = res * arr[i];
    }
    *dest = res;
}
```

![图 5-28 multiply3 使用 2 * 1a 循环展开的数据流图](img/图%205-28%20multiply3%20使用%202%20*%201a%20循环展开的数据流图.png)

函数 `multiply6` 这种形式称为 `2 * 1a` 循环展开，这种方法通过重变换结合打破由延迟界限设下的限制。从数据流图可以看到关键路径上的浮点乘法都只有 1 个，每 5 个周期可以并行计算出 2 个乘积，所以 CPE 变为 2.5 。数据流图的变化与练习题 5.5 和练习题 5.6 类似，通过将一个操作移出关键路径提升性能。

### 性能限制因素 `P378`

- 延迟界限是一个基本的下界，即一条数据相关链上所有延迟之和

- 吞吐量界限则是另一个下界。假设一个程序一共需要 N 个某种运算的计算，而微处理器只有 C 个能执行这个操作的功能单元，并且这些单元的发射时间为 I 。那么这个程序的执行至少需要 `N * I / C` 个周期

- 如果并行度超过了可用的寄存器数量，那么编译器会将某些临时值放到内存中，某些操作就需要读写内存，反而会降低性能

- 分支预测错误会降低性能，正如 [处理器体系结构](archlab.md) 中提到的一样，我们可以使用条件传送避免分支预测

### 性能提高技术 `P387`

- 高级设计：选择适当的算法和数据结构
- 基本编码规则：避免限制优化的因素，让编译器产生高效的代码
    - 消除连续的函数调用：在可能时，将计算移到循环外
    - 消除不必要的内存引用：引入临时变量保存中间结果
- 低级优化：结构化代码以利用硬件性能
    - 展开循环，降低开销，并使得进一步的优化成为可能
    - 通过使用诸如多个累积变量和重结合变换等技术，找到方法提高指令级并行
    - 用功能性的风格重写条件操作，使得编译采用条件数据传送

## 小结

本章介绍的性能提升技术中的高级设计和基本编码规则在日常开发中经常使用，也是我们经常关注的优化点；而低级优化部分更适合编译器或者底层等十分关注性能的开发情况使用，平时业务中基本不会接触到，这种优化方式会增大对业务代码逻辑的理解难度，在目前性能过剩且支持水平扩展的情况下，还是尽可能以代码通俗易懂为目标进行开发。在真正遇到性能问题时，还是要关注高级设计和基本编码规则部分，根据性能测试结果进行针对性优化部分函数逻辑。
