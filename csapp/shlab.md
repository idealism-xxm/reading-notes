## 简介

Shell Lab 属于《深入理解计算机》第八章——异常控制流。异常控制流发生在计算机系统的各个层次，是计算机系统中提供并发的基本机制。

## 知识点回顾

异常控制流是操作系统用来实现 I/O 、进程、虚拟内存和并发的基本机制。 `P501`

### 异常 `P502`

异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。异常就是控制流中的突变，用来相应处理器状态中的某些变化。 `P502`

![图 8-1 异常的剖析](img/图%208-1%20异常的剖析.png)

当异常处理程序完成处理后，根据引起异常的事件类型，会发生以下 3 种情况中的一种： `P502`

- 处理程序将控制返回给当前指令 `I_curr` ，即当事件发生时正在执行的指令
- 处理程序将控制返回给 `I_next` ，如果没有发生异常将会执行下一条指令
- 处理程序终止被中断的程序

异常可以分为四类，异步异常是由处理器外部的 I/O 设备中的事件产生的，同步异常是执行一条指令的直接产物。 `P504`

| 类别 | 原因 | 同步/异步 | 返回行为 |
| --- | --- | --- | --- |
| 中断 | 来自 I/O 设备的信号 | 异步 | 总是返回到下一条指令 |
| 陷阱 | 有意的异常 | 同步 | 总是返回到下一条指令 |
| 故障 | 潜在可恢复的错误 | 同步 | 可能返回到当前指令 |
| 终止 | 不可恢复的错误 | 同步 | 不会返回 |

![图 8-5 ~ 图 8-8 四种异常处理流程](img/图%208-5%20~%20图%208-8%20四种异常处理流程.png)

### 进程 `P508`

一提到进程就会想到课本里那句经典的话：进程是资源分配的最小单位，线程是 CPU 调度的最小单位。

进程提供给应用程序两个重要的抽象： `P508`

- 一个独立的逻辑控制流：它提供给每个程序一个假象，好像应用程序在独占地使用处理器
- 一个私有的地址空间：它提供给每个程序一个假象，好像应用程序在独占地使用内存系统

进程通常运行在用户模式中，它不能执行特权指令，也不能直接引用地址空间中的内核区内的代码和数据；为了执行这些操作，它必须进入内核模式，而进入内核模式的唯一方法是通过诸如中断、故障或陷入系统调用这样的异常。 `P510`

操作系统内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占进程所需的状态。 `P511`

操作系统内核使用上下文切换这种较高层形式的异常控制流来实现多任务。上下文切换建立在前面提到的较低层异常机制之上，它可以将控制转移到新的进程： `P511`

- 保存当前进程的上下文
- 恢复某个先前被抢占的进程被保存的上下文
- 将控制传递给这个新恢复的进程

![图 8-14 进程上下文切换](img/图%208-14%20进程上下文切换.png)

### 进程控制 `P513`

Unix 提供了大量从 C 程序中操作进程的系统调用，书中本节详细介绍了一些重要的函数，相当于部分 API 文档，不需要仔细研究每个参数，只需要了解函数可以干什么即可，在实际使用时再具体钻研。

| 函数 | 作用 |
| --- | --- |
| `getpid` | 获取当前进程的 PID |
| `getppid` | 获取当前进程父进程的 PID |
| `exit` | 以 `status` 退出状态来终止进程 |
| `fork` | 创建一个新的运行的子进程 |
| `waitpid` | 等待子进程终止或停止 |
| `wait` | `waitpid` 的简单版本， `wait(&status)` 等价于 `waitpid(-1, &status, 0)` |
| `sleep` | 当前进程挂起一段指定的时间 |
| `pause` | 当前进程休眠，直到收到一个信号 |
| `execve` | 加载并运行可执行目标文件 |
| `getenv` | 获取一个环境变量 |
| `setenv` | 设置一个环境变量 |
| `unsetenv` | 删除一个环境变量 |

其中 `fork` 和 `execve` 两个函数尤为重要，两者配合起来就可以运行一个程序。 `P524`

`fork` 新创建的子进程几乎但不完全与父进程相同（最大区别就是有不同的 PID）。 `fork` 函数有以下特点： `P514`

- 调用一次，返回两次。一次返回到父进程，返回值为子进程 PID ；一次返回到子进程，返回值为 0
- 并发执行。父进程和子进程是并发运行的独立进程
- 相同但是独立的地址空间：子进程得到与父进程用户虚拟地址空间相同但独立的一份副本，包括代码和数据段、堆、共享库以及用户栈
- 共享文件：子进程获得与父进程任何打开文件描述符相同的副本，这意味着子进程可以读写父进程在调用 `fork` 前打开的任何文件

![图 8-17 嵌套 fork 的进程图](img/图%208-17%20嵌套%20fork%20的进程图.png)

`execve(filename, argv, envp)` 加载并运行可执行目标文件 `filename` ，且带有参数列表 `argv` 和环境变量列表 `envp` 。 `execve` 函数有以下特点： `P521`

- 调用一次，从不返回。调用成功则不返回，调用失败才会返回到调用进程，返回值为 -1
- 控制传递给新程序的主函数

从程序员的角度，我们可以认为进程总是处于下面三种状态之一：

- 运行：进程要么在 CPU 上执行，要么在等待被执行且最终会被内核调度
- 停止：进程的执行被挂起，且不会被调度。当收到 `SIGSTOP`, `SIGTSTP`, `SIGTTIN`, `SIGTTOU` 信号时，进程就停止，并且保持停止直到它收到一个 `SIGCONT` 信号，在这个时刻，进程再次开始运行
- 终止：进程永远地停止了。进程会因为三种原因终止：
    - 收到一个信号，该信号的默认行为是终止进程
    - 从主程序中返回
    - 调用 `exit` 函数

### 信号 `P526`

Linux 信号允许进程和内核中断其他进程，它通知进程系统中发生了一个某种类型的事件。 `P526`

传送一个信号到目的程序是由两个不同步骤组成的： `P527`

- 发送信号。内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。一个进程可以发送信号给自己。
- 接受信号。当目的进程被内核强迫以某种方式对信号的发送作出反应时，它就接受了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序的用户层函数捕获这个信号。

![图 8-27 信号处理](img/图%208-27%20信号处理.png)

一个发出而没有被接收的信号叫做待处理信号。 **在任何时刻，一种类型至多会有一个待处理信号，后来的相同待处理信号会被简单地丢弃。** 一个进程可以有选择性地阻塞接收某种信号，此时该信号仍然可以被发送，但是不会被接受，直至进程取消对该信号的阻塞。 `P528`

书中本节同样详细介绍了一些重要的函数，相当于部分 API 文档，不需要仔细研究每个参数，只需要了解函数可以干什么即可，在实际使用时再具体钻研。

| 函数 | 作用 |
| --- | --- |
| `getpgrp` | 获取当前进程的进程组 ID （默认一个子进程和它的父进程同属于一个进程组） |
| `setpgid` | 设置一个进程的进程组 ID |
| `kill` | 向一个进程发送 `SIGKILL` 信号 |
| `alarm` | 向一个进程发送 `SIGALRM` 信号 |
| `signal` | 修改某个信号的处理程序（`SIGSTOP` 和 `SIGKILL` 的默认行为不能修改） |
| `sigprocmask` | 改变当前阻塞的信号集合 |
| `sigemptyset` | 初始化一个信号集合为空集合 |
| `sigfillset` | 把每个信号都添加到一个信号集合中 |
| `sigaddset` | 把一个信号添加到一个信号集合中 |
| `sigdelset` | 把一个信号从一个信号集合中删除 |
| `sigismember` | 判断一个信号是否在一个信号集合中 |
| `sigaction` | 设置信号处理函数时，明确指定想要的信号处理语义，不常使用 |
| `sigsuspend` | 用一个信号集合替换当前的阻塞集合，然后挂起当前进程，直到收到一个信号 |

信号处理程序可以被其他信号处理程序中断。 `P531`

信号处理程序的属性： `P533`

- 处理程序与主程序并发运行，共享同样的全局变量，因此可能与主程序和其他处理程序相互干扰
- 如何以及何时接收信号的规则常常有违直觉
- 不同的系统有不同的信号处理语义

编写安全、正确和可移植的信号处理程序的基本规则： `P533`

- 安全地处理信号
    - 处理程序要尽可能简单
    - 在处理程序中只调用一部信号安全的函数（函数要么可重入，要么不能被信号处理程序中断）
    - 保存和恢复 `errno`
    - **阻塞所有的信号，保护对共享全局数据结构的访问**
    - 用 `volatile` 声明全局变量
    - 用 `sig_atomic_t` 声明标志
- 正确地处理信号：由于每种类型最多只能有一个未处理的信号，所以信号可能会被丢弃，不能用信号来对其他进程中发生的事件计数
- 可移植地处理信号：使用 `sigaction` 来明确信号处理语义

### 非本地跳转 `P546`

非本地跳转通过 `setjmp` 和 `longjmp` 函数来实现。它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。 `P547`

看到非本地跳转的用法，很快就能想到 C++ 和 Java 中的异常机制。后面书中也提到 C++ 和 Java 中的异常机制是较高层次的，是非本地跳转的更加结构化版本。

`setjmp` 只被调用一次，但返回多次：一次是当第一个次调用 `setjmp` ，而调用环境保存在缓冲区 `env` 中时；一次是为每个相应的 `longjmp` 调用。 `P547`

`longjmp` 被调用一次，但从不返回。 `P547`

## 准备

可以在 [官网](http://csapp.cs.cmu.edu/3e/labs.html) 下载 Architecture Lab 相关的程序。

开始前需要阅读 [Shell Lab writeup](http://csapp.cs.cmu.edu/3e/shlab.pdf) ，可以知道本次 Lab 已经帮我们搭建好了一个 shell 程序的框架，只需要我们完成几个必备的功能即可。

本次需要使用的程序依旧需要在 Docker 中运行，将本地 Lab 的目录挂载进容器中即可：

```shell script
docker run -ti -v {PWD}:/csapp ubuntu:18.04
```

进入容器后需要安装一些必须软件以便后续能成功运行：

```shell script
apt-get update && apt-get -y install gcc make flex bison libgetopt-complete-perl
```

然后就可以愉快的开始闯关了。

## 闯关

## 总结
