## 简介

本章为《深入理解计算机系统》第四章——处理器体系结构，从一个精简版的指令集 `Y86-64` 开始，将指令的执行分成五个阶段，并首先实现了一个顺序版的处理器 `SEQ` 使得我们能在一个超长的周期内执行完一条指令，再引入流水线并增加寄存器保存每个阶段状态以并行执行，又增加转发逻辑使得两条指令相互依赖的值能快速传递，最后引入了流水线控制逻辑处理特殊情况，最终完成了一个代表 20 世纪 80 年代中期的处理器设计水平的处理器 `PIPE` 。

由于本章涉及的知识很多都没接触过，很容易就懵，看了两遍才大致理解一些理论方面的知识，各种书本上具体的用例讲解基本能够理解但没有太多深究，在此也仅回顾本章的核心知识点，其他方面还需要结合 Lab 再研究。

## 知识点回顾

### 出入栈指令

`pushq %rsp`: 先将寄存器 `%rsp` 内的值放入栈顶，再将寄存器 `%rsp` 内的值减去 `8` ，即： `movq %rsp, -8(%rsp); subq 8, %rsp;`

`popq %rsp`: 先取出栈顶的值 `valM` ，再将寄存器 `%rsp` 内的值加上 `8` ，最后再将 `valM` 放入寄存器 `%rsp` 内，即： `addq 8, %rsp; movq -8(%rsp), %rsp;`

出入栈指令其实很简单明了，可以发现写成对应的指令后互为相反操作。寄存器 `%rsp` 与其他寄存器没有任何区别，不需要单独记忆，不要被特殊寄存器干扰。

对应习题： `4.7`,`4.8` (`P255`) ，对应家庭作业： `4.45`, `4.46` (`P327`)，可以查看书中 `P268` 所示的出入栈每个阶段的硬件操作加深记忆，从硬件本质上理解是如何处理的。

![图 4-20 Y86-64 指令 pushq 和 popq 在顺序实现中的计算.png](img/图%204-20%20Y86-64%20指令%20pushq%20和%20popq%20在顺序实现中的计算.png)

### 硬件设计

实现一个数字系统需要三个主要的组成部分：组合逻辑、存储器和时钟信号。 `P256`

#### 组合逻辑

组合逻辑简单地响应输入的变化，产生等于输入的某个函数的输出，不会进行部分求值（高级语言中的逻辑计算存在部分求值，即短路语义） `P258`

#### 存储器

存储器按位存储信息，由同一个时钟控制将新值加载到存储器中，考虑以下两类存储器： `P262`
- 时钟寄存器（简称寄存器）：存储单个位或字
- 随机访问存储器（简称内存）：存储多个字，用地址来选择读写哪个字。包括：虚拟内存系统、寄存器文件

在硬件中，寄存器直接将它的输入和输出线连接到电路的其他部分，可称为硬件寄存器（时钟寄存器）；在机器级编程中，寄存器代表 CPU 中为数不多的可寻址的字，地址为寄存器 ID ，可称为程序寄存器。 `P262`

硬件寄存器大多数时候保持在稳定状态，产生的输出等于它的当前状态。只要时钟是低电位，寄存器的输出就保持不变；当时钟变成高电位时，输入信号就会加载到寄存器中，从而输出也会变化为新的状态。硬件寄存器作为电路中不同部分中的组合逻辑之间的屏障，当每个时钟到达上升沿时，值才会从硬件寄存器的输入传送到输出。 `P262`

### SEQ 处理器 `P264`

SEQ 处理器是 `Y86-64` 的顺序实现，即每个周期执行处理完一条完整指令所需的所有步骤。

SEQ 的实现中有四个硬件单元需要通过时钟信号来控制：程序计数器、条件码寄存器、数据内存和寄存器文件。这四个硬件单元存储的数据视作状态，而这些所有状态更新实际上是同时发生的，且只在时钟上升开始下一个周期时。 `P275`

- 本周期内执行的指令阶段操作都通过组合逻辑进行传递，不存储任何状态，完成全部组合逻辑计算后，在下一个周期开始时才将状态存储到对应的硬件中。
- 状态虽然会在下一个周期才会被存储，但在下一条指令执行前，所有的状态都会更新（书中 `P276` 有以下相关图示）

![图 4-25 信号传播通过组合逻辑，在下一个周期开始时，新值会被加载到状态单元中.png](img/图%204-25%20信号传播通过组合逻辑，在下一个周期开始时，新值会被加载到状态单元中.png)

`Y86-64` 指令集遵循从不回读的原则：处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。 `P275`

- 第一遍读到这里时很懵，前面没有看懂导致这里怎么都想不通了；第二遍再看时把前后相关的部分串起来理解，很多问题都迎刃而解了。这里的状态如上所说是前面介绍的四个硬件单元中存储的状态（并非具体阶段中组合逻辑计算出来的值，也非硬件寄存器中存储的阶段状态），即当前指令写入的状态不会由当前指令后续的阶段读取到，因为这些状态只会在当前指令完成后才被存储到硬件单元中。

当同一个周期内两个写端口都试图对一个程序寄存器继续写时，只有较高优先级端口上的写才会发生。寄存器文件中的 M 写端口优先级高于 E 写端口，因此执行 `popq %rsp` 时能满足前面所提到的确定行为，使得行为类似： `addq 8, %rsp; movq -8(%rsp), %rsp;` （对应习题： `4.22` (`P279`)）

### 预测下一个 PC

为了使得每个周期都有一个新指令开始执行，那么必须在取出当前指令后马上确定下一个位置。有时候我们不能确定当前指令的下一条指令的位置，这就需要我们进行预测。 `P294`

- 条件转移指令：下一条指令的地址要么是 `valC` （选择了分支），要么是 `valP` （没有选择分支）。我们实现的流水线总是预测选择了分支，即下一条指令的地址是 `valC`
- `ret` 指令：下一条指令需要等当前指令通过访存阶段后才能确定。我们实现的流水线仅简单暂停处理新指令，直到 `ret` 指令通过写回阶段
    - 开始执行 `ret` 指令后，由于前面的指令还在流水线中，很可能栈顶不是返回地址（回想函数的汇编代码可以发现， `ret` 指令前面往往还有一条 `subq xx, %rsp` 的指令，用于释放当前函数使用的栈空间）
    - 对大多数程序来说，预测返回值很容易，因为 `call` 和 `ret` 是成对出现的。可以通过在取指单元中放入一个硬件栈，每次执行 `call` 指令时，将其返回地址压入栈中；当执行 `ret` 指令时就弹出栈顶的值，作为预测的返回地址
- `call` 和 `jmq` 指令：下一条指令的地址是指令中的常数数字 `valC`
- 其他指令：下一条指令的地址就是根据 PC 和当前指令长度计算后的数字 `valP`

分支预测错误会极大地降低程序的效率，因此在可能的时候，要使用条件数据传送而不是条件控制转移。 `P295`

很久以前就看到 StackOverflow 上一个分支预测相关的问题：[为什么处理一个有序数组比处理一个无序数组快？](https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array) 第一条回答中也提到了 `GCC` 在 `-O3` 下会在可能的时候会使用条件数据传送。（结合前段时间看的一篇关于编译器优化的分享后，觉得我们写代码时其实不用过分关注每一段具体代码的相关效率，很多都能被编译器优化（例如：`i++` 和 `++i` 开了优化都一样），我们更应该关注整体设计方面的效率。

### 流水线冒险

当相邻指令间存在相关时会导致出现问题，这些相关可能会导致流水线产生计算错误，称为冒险。 `P295`

- 数据冒险：下一条指令会用到这一条指令计算出的结果
- 控制冒险：一条指令要确定下一条指令的位置，例如执行跳转、调用和返回指令时

数据冒险的可能性分析： `P298`

- 程序寄存器：寄存器文件的读写在不同的阶段，不同指令之间可能出现相互作用
- 程序计数器：更新和读取程序计数器之间的冲突导致了控制冒险，只有预测错误的分支和 `ret` 指令才会产生冒险，需要特殊处理
- 内存：对数据内存的读和写都发生在访存阶段，当一条读内存的指令到达访存阶段时，前面所有要写内存的指令都已经执行完成这个阶段了，所以一般情况下不会出现冒险（有些能修改自身代码的程序会出现冒险，因为指令内存的访问在取指阶段）
- 条件码寄存器：整数操作会在执行阶段写这些寄存器，而条件传送指令会在执行阶段读这些寄存器、条件转移指令会在访存阶段读这些寄存器，当条件传送指令/条件转移指令到达执行阶段时，前面所有要写条件码寄存器的指令都已经执行完成这个阶段了，所以不会出现冒险
- 状态寄存器：每条指令都有与之相关的状态码相关联，当异常发生时，处理器需要有条理地停止

综上所述：我们只需要处理程序寄存器数据冒险、控制冒险，并确保能够正确处理异常即可。 `P298`

1. 用暂停来避免数据冒险：当存在数据冒险时，处理器会让接下来的一条指令停顿在译码阶段，直到它的源操作数的指令通过了写回阶段。机器通过动态插入一条 `nop` 指令，使得当前指令的后续阶段执行 `nop` 指令 `P298`
2. 用转发来避免数据冒险：又称旁路，将结果值直接从一个流水线阶段传到较早阶段。通过增加一些额外的数据连接和控制逻辑，将以下五个转发源直接传到译码阶段，转发目的为 `valA` 和 `valB`： `P300`
    - 写回阶段对程序寄存器未进行的写：转发源为 `W_valE` 和 `W_valM`
    - 访存阶段对程序寄存器未进行的写：这个写操作的寄存器地址和值已经确定，将会在写回阶段执行，转发源为 `M_valE` 和 `m_valM` ，其中 `m_valM` 为刚刚从内存中读出的值且其目标为写端口 `M`
    - 执行阶段对程序寄存器未进行的写：这个写操作的寄存器地址和值已经确定，将会在写回阶段执行，转发源为 `e_valE` ，其中 `e_valE` 为 ALU 刚刚计算出的值且其目标为写端口 `E`
    ![图 4-52 流水线化的最终实现—— PIPE 的硬件结构.png](img/图%204-52%20流水线化的最终实现——%20PIPE%20的硬件结构.png)
3. 加载/使用数据冒险：加载/使用数据冒险不能单纯通过转发来解决，因为内存读在流水线发生的比较晚。例如 `mrmovq (%rdx), %rax; addq %rbx, %rax;` 就存在这种冒险，当 `mrmovq` 指令刚刚从内存中读出值时， `addq` 指令早在上一个周期已经使用了对应的寄存器，转发逻辑无法将值送回到过去。我们可以将暂停和转发结合起来避免加载/使用数据冒险（这种方法称为加载互锁），这种情况下只需要暂停 `addq` 指令一个周期即可转发 `mrmovq` 从内存中读出的值 `P303`
4. 避免控制冒险：当处理器无法根据处于取指阶段的当前指令来确定下一条指令的地址时，就会出现控制冒险。正如前面所提到的，控制冒险只会发生在 `ret` 指令（暂停处理新指令）和条件转移指令（总是预测会进行跳转），且条件传送指令只有在分支预测错误时才会造成麻烦。因此我们只需要处理条件传送指令分支预测错误这种情况，此时我们需要取消错误指令的执行，并开始执行正确的指令（条件传送指令后面的那条指令） `P304`
    - 条件传送指令会在执行阶段就计算出条件码，而此时后面只有两条错误指令，分别处于取指阶段和译码阶段，这两个阶段都不会修改程序员可见状态，所以可以简单取消它们后续阶段的执行 `P306`

### 异常处理

`Y86-64` 指令集体系结构包括三种不同的内部产生的异常，暂不处理网络接口接收新包、点击鼠标等外部异常。 `P306`

- `halt` 指令
- 有非法指令和功能码组合的指令
- 取指或数据读写试图访问一个非法地址

在设计流水线的处理器时，我们将异常状态和该指令的其他信息一起沿着流水线传播，直到它到达写回阶段。在此，流水线控制逻辑发现出现了异常，并停止执行。 `P307`

指令的异常有三个细节需要注意： `P307`

- 同时存在多个指令的异常：让流水线中最深的指令（最早开始的指令）引起的异常优先级最高
- 一条引起异常的指令由于分支预测错误被取消：如前面所说，异常状态会沿流水线传播，且只在访存/写回阶段才会进行处理，而由于分支错误被取消的指令最多只达到译码阶段，所以被取消的异常指令不会修改程序员可见状态，也不会造成其他影响
- 所有引起异常的指令后面的指令都不能改变程序员可见状态：当处于访存/写回阶段中的指令引起异常时，流水线控制逻辑需要禁止更新条件码寄存器和数据内存

### 流水线控制逻辑

前面提到的数据转发和分支预测只能处理部分逻辑，以下四种情况只能由流水线控制逻辑处理： `P314`

- 加载/使用冒险：在一条从内存中读出一个值的指令和一条使用该值的指令之间，流水线必须暂停一个周期
- `ret` 指令：流水线必须暂停直到 `ret` 指令到达写回阶段
- 分支预测错误：取消错误的指令，并从跳转指令后面的那条指令开始取指
- 异常：禁止异常指令后面的指令更新程序员可见状态，并且在异常指令到达写回阶段时，停止执行
    - 禁止执行阶段的指令设置条件码
    - 向内存阶段中插入气泡，以禁止向数据内存中写入
    - 当写回阶段有异常指令时，暂停写回阶段，从而暂停流水线