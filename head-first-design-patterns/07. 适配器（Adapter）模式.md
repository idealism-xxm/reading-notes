#### 思考题
你能想到真实世界中，还有哪些适配器的例子？ `P236`
- HDMI 转 VGA 转换器
- Type-C 转 3.5mm 线

#### 适配器模式解析
客户使用适配器的过程： `P241`
1. 客户通过目标接口调用适配器的方法对适配器发出请求
2. 适配器使用被适配者接口把请求转换成被适配者的一个或多个调用接口
3. 客户接收到调用的结果，但并未察觉这一切是适配器在起转换作用（**客户和被适配者是解耦的，一个不知道另一个**）

#### 思考题
如果我们也需要一个将鸭子转换成火鸡的适配器，我们称它为 `DuckAdapter`。请写下这个类。你如何处理飞行方法（毕竟我们知道鸭子飞得比火鸡远）？ `P242`
```java
public class DuckAdapter implements Turkey {
    Duck duck;
    int count = 0;

    public DuckAdapter(Duck duck) {
        this.duck = duck;
    }

    public void gobble() {
        duck.quack();
    }

    public void fly() {
        ++ count;
        if(count == 5) {
            count = 0;
            duck.fly();
        } else {
            System.out.println("I'm preparing to fly.");
        }
        // 答案用的是随机数取模的方法，平均下来每调用5次飞一下
    }
}
```

#### 适配器模式
将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 `P243`
![适配器模式](http://note.youdao.com/yws/res/4342/WEBRESOURCE17d344ac06c84ab0b260dd9f10a58e73)

##### 特点
- 让客户从实现的接口解耦 `P243`
- 使用对象组合，以修改的接口包装被适配者 `P243`
- 把客户和接口绑定起来，而不是和实现绑定起来 `P243`

#### 思考题
对象适配器（使用组合）和类适配器（使用继承）使用两种不同的适配方法。这两种实现的差异如何影响适配器的弹性？ `P244`

##### 对象适配器
- 更具有弹性，不仅可以适配某个类，还可以适配其任何子类 `P247`
- 需要一个被适配者的对象，但可动态变更被适配者
- 难以覆盖被适配者的行为，只能通过继承的方式实现
- 只暴露目标接口的行为

##### 类适配器
- 只能适配特定一个类，但不需要重新实现整个被适配者 `P247`
- 本身就是一个被适配者的对象，但不能动态变更被适配者
- 便于直接在适配器内覆盖被适配者的行为
- 不仅暴露目标接口的行为，也暴露被适配者的行为

#### 思考题
某些交流电适配器所做的事情不只是改变接口，它们还加了一些其他的特性，例如：电涌保护、指示灯、警报声等。
如果要你实现这类特性，你要使用什么模式？ `P251`
- 装饰器模式

#### 所思所想
- 适配器模式也比较常使用，即使没看过设计模式，凭借自己的经验也能写出来，主要目的就是适配不兼容的接口。有一次为了在兼容原有特化搜索接口的基础上，增加一个定制化搜索接口，保证一段时间内两个接口可并存调用，并将一部分特化搜索接口的流量切到定制化搜索接口上，同时又要保证接口调用方无感知，就写了一个适配器，将特化搜索参数转换成定制化搜索的参数，并实现部分流量且切入定制化搜索接口。